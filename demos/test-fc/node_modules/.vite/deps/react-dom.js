import {
  REACT_ELEMENT_TYPE,
  __export
} from "./chunk-IQX2HDWY.js";

// packages/react-dom/src/root.ts
var root_exports = {};
__export(root_exports, {
  createRoot: () => createRoot
});

// packages/react-reconciler/src/fiberFlags.ts
var NoFlags = 0;
var Placement = 1;
var Update = 2;
var ChildDeletion = 4;
var MutationMask = Placement | Update | ChildDeletion;

// packages/react-reconciler/src/workTags.ts
var FunctionComponent = 0;
var HostRoot = 3;
var HostCompoment = 5;
var HostText = 6;

// packages/react-reconciler/src/fiber.ts
var FiberNode = class {
  tag;
  // 节点类型 () -> {}  -> FunctionComponent
  pendingProps;
  // 最新的props
  key;
  type;
  // 当前节点的组件类型(函数组件，类组件，标签名)
  stateNode;
  // DOM节点或者是组件实例
  ref;
  // 引用，如(ref,React.createRef)
  return;
  // 父fiber
  sibling;
  // 兄弟fiber
  child;
  // 第一个子fiber节点
  index;
  // 当前节点在其兄弟节点中的位置
  memoizedProps;
  // 上一次渲染使用的props
  memoizedState;
  // 状态
  alternate;
  // 指向上次渲染的fiber(current和workInProgress的互指)
  flags;
  // fiber需要执行的操作
  subtreeFlags;
  // 当前节点的子树的副作用标识
  updateQueue;
  // 存放state更新队列(如setState的调用)
  constructor(tag, pendingProps, key) {
    this.tag = tag;
    this.key = key;
    this.stateNode = null;
    this.type = null;
    this.return = null;
    this.sibling = null;
    this.child = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.memoizedProps = null;
    this.memoizedState = null;
    this.alternate = null;
    this.updateQueue = null;
    this.flags = NoFlags;
    this.subtreeFlags = NoFlags;
  }
};
var FiberRootNode = class {
  container;
  // 宿主环境的容器，比如 DOM 中的 #root
  current;
  // 指向当前渲染中的根 FiberNode（HostRootFiber）
  finishedWork;
  // 调度完成、等待 commit 的 Fiber 树
  constructor(container, hostRootFiber) {
    this.container = container;
    this.current = hostRootFiber;
    hostRootFiber.stateNode = this;
    this.finishedWork = null;
  }
};
var createWorkInProcess = (current, pendingProps) => {
  let wip = current.alternate;
  if (wip === null) {
    wip = new FiberNode(current.tag, pendingProps, current.key);
    wip.stateNode = current.stateNode;
    wip.alternate = current;
    current.alternate = wip;
  } else {
    wip.pendingProps = pendingProps;
    wip.flags = NoFlags;
    wip.subtreeFlags = NoFlags;
  }
  wip.type = current.type;
  wip.updateQueue = current.updateQueue;
  wip.child = current.child;
  wip.memoizedProps = current.memoizedProps;
  wip.memoizedState = current.memoizedState;
  return wip;
};
var createFiberFromElement = (element) => {
  const { type, key, props } = element;
  let fiberTag = FunctionComponent;
  if (typeof type === "string") {
    fiberTag = HostCompoment;
  } else if (typeof type !== "function" && __DEV__) {
    console.warn("未定义的type类型", type);
  }
  const fiber = new FiberNode(fiberTag, props, key);
  fiber.type = type;
  return fiber;
};

// packages/react-reconciler/src/updateQueue.ts
var createUpdate = (action) => {
  return {
    action
  };
};
var createUpdateQueue = () => {
  return {
    shared: {
      pending: null
    }
  };
};
var enqueueUpdate = (updateQueue, update) => {
  updateQueue.shared.pending = update;
};
var processUpdateQueue = (baseState, pendingUpdate) => {
  const result = {
    memoizedState: baseState
  };
  if (pendingUpdate !== null) {
    const action = pendingUpdate.action;
    if (action instanceof Function) {
      result.memoizedState = action(baseState);
    } else {
      result.memoizedState = action;
    }
  }
  return result;
};

// packages/react-reconciler/src/childFibers.ts
function ChildReconciler(shouldTrackEffects) {
  function reconcileSingleElement(returnFiber, currentFiber, element) {
    const fiber = createFiberFromElement(element);
    fiber.return = returnFiber;
    return fiber;
  }
  function reconcilSingleTextNode(returnFiber, currentFiber, content) {
    const fiber = new FiberNode(HostText, { content }, null);
    fiber.return = returnFiber;
    return fiber;
  }
  function placeSingleChild(fiber) {
    if (shouldTrackEffects && fiber.alternate === null) {
      fiber.flags |= Placement;
    }
    return fiber;
  }
  return function reconcileChildFibers2(returnFiber, currentFiber, newChild) {
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(returnFiber, currentFiber, newChild)
          );
        default:
          if (__DEV__) {
            console.warn("未实现的concile类型", newChild);
          }
          break;
      }
    }
    if (typeof newChild === "string" || typeof newChild === "number") {
      return placeSingleChild(
        reconcilSingleTextNode(returnFiber, currentFiber, newChild)
      );
    }
    if (__DEV__) {
      console.warn("未实现的concile类型", newChild);
    }
    return null;
  };
}
var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

// packages/react-reconciler/src/fiberHooks.ts
var renderWithHooks = (wip) => {
  const Component = wip.type;
  const props = wip.pendingProps;
  const children = Component(props);
  return children;
};

// packages/react-reconciler/src/beginWork.ts
var beginWork = (wip) => {
  switch (wip.tag) {
    case HostRoot:
      return updateHostRoot(wip);
    case HostCompoment:
      return updateHostComponent(wip);
    case HostText:
      return null;
    case FunctionComponent:
      return updateFunctionComponent(wip);
    default:
      if (__DEV__) {
        console.warn("beginWork未实现的部分");
      }
      break;
  }
  return null;
};
var updateFunctionComponent = (wip) => {
  const nextChildren = renderWithHooks(wip);
  reconcileChildren(wip, nextChildren);
  return wip.child;
};
var updateHostRoot = (wip) => {
  const baseState = wip.memoizedState;
  const updateQueue = wip.updateQueue;
  const pending = updateQueue.shared.pending;
  updateQueue.shared.pending = null;
  const { memoizedState } = processUpdateQueue(baseState, pending);
  wip.memoizedState = memoizedState;
  const nextChildren = wip.memoizedState;
  reconcileChildren(wip, nextChildren);
  return wip.child;
};
var updateHostComponent = (wip) => {
  const nextProps = wip.memoizedProps;
  const nextChildren = nextProps.children;
  reconcileChildren(wip, nextChildren);
  return wip.child;
};
var reconcileChildren = (wip, children) => {
  const current = wip.alternate;
  if (current !== null) {
    wip.child = reconcileChildFibers(wip, current?.child, children);
  } else {
    wip.child = mountChildFibers(wip, null, children);
  }
};

// packages/react-dom/src/hostConfig.ts
var createInstance = (type, props) => {
  const element = document.createElement(type);
  return element;
};
var appendInitialChild = (parent, child) => {
  parent.appendChild(child);
};
var createTextInstance = (content) => {
  return document.createTextNode(content);
};
var appendChildToContainer = appendInitialChild;

// packages/react-reconciler/src/completeWork.ts
var completeWork = (wip) => {
  const newProps = wip.pendingProps;
  const current = wip.alternate;
  switch (wip.tag) {
    case HostCompoment:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createInstance(wip.type, newProps);
        appendAllChildren(instance, wip);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostText:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createTextInstance(newProps.content);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostRoot:
      bubbleProperties(wip);
      return null;
    case FunctionComponent:
      bubbleProperties(wip);
      return null;
    default:
      if (__DEV__) {
        console.warn("未实现的情况");
      }
      break;
  }
};
var appendAllChildren = (parent, wip) => {
  let node = wip.child;
  while (node !== null) {
    if (node?.tag === HostCompoment || node?.tag === HostText) {
      appendAllChildren(parent, node.stateNode);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === wip) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === wip) {
        return;
      }
      node = node?.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
};
var bubbleProperties = (wip) => {
  let subtreeFlags = NoFlags;
  let child = wip.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child.return = wip;
    child = child.sibling;
  }
  wip.subtreeFlags |= subtreeFlags;
};

// packages/react-reconciler/src/commitWork.ts
var nextEffect = null;
var commitMutationEffects = (finishedWork) => {
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const child = nextEffect.child;
    if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
      nextEffect = child;
    } else {
      up: while (nextEffect !== null) {
        commitMutationEffectsOnFiber(nextEffect);
        const sibling = nextEffect.sibling;
        if (sibling !== null) {
          nextEffect = sibling;
          break up;
        }
        nextEffect = nextEffect.return;
      }
    }
  }
};
var commitMutationEffectsOnFiber = (finishedWork) => {
  const flags = finishedWork.flags;
  if ((flags & Placement) !== NoFlags) {
    commitPlacement(finishedWork);
    finishedWork.flags &= ~Placement;
  }
};
var commitPlacement = (finishedWork) => {
  if (__DEV__) {
    console.warn("执行Placement操作", finishedWork);
  }
  const hostParent = getHostParent(finishedWork);
  if (hostParent !== null) {
    appendPlacementNodeIntoContainer(finishedWork, hostParent);
  }
};
var getHostParent = (fiber) => {
  let parent = fiber.return;
  while (parent) {
    const parentTag = parent.tag;
    if (parentTag === HostCompoment) {
      return parent.stateNode;
    }
    if (parentTag === HostRoot) {
      return parent.stateNode.container;
    }
    parent = parent.return;
  }
  if (__DEV__) {
    console.warn("未找到host parent", parent);
  }
  return null;
};
var appendPlacementNodeIntoContainer = (finishedWork, hostParent) => {
  if (finishedWork.tag === HostCompoment || finishedWork.tag === HostText) {
    appendChildToContainer(hostParent, finishedWork.stateNode);
    return;
  }
  const child = finishedWork.child;
  if (child !== null) {
    appendPlacementNodeIntoContainer(child, hostParent);
    let sibling = child.sibling;
    while (sibling !== null) {
      appendPlacementNodeIntoContainer(sibling, hostParent);
      sibling = sibling.sibling;
    }
  }
};

// packages/react-reconciler/src/workLoop.ts
var workInProgress = null;
function prepareFreshStack(root) {
  workInProgress = createWorkInProcess(root.current, {});
}
var scheduleUpdateOnFiber = (fiber) => {
  const root = markUpdateFromFiberToRoot(fiber);
  renderRoot(root);
};
var markUpdateFromFiberToRoot = (fiber) => {
  let node = fiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  if (node.tag == HostRoot) {
    return node.stateNode;
  }
  return null;
};
function renderRoot(root) {
  prepareFreshStack(root);
  do {
    try {
      workLoop();
      break;
    } catch (e) {
      if (__DEV__) {
        console.log("root", root);
        console.warn("workLoop发生错误", e);
      }
      workInProgress = null;
    }
  } while (true);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
var commitRoot = (root) => {
  const finishedWork = root.finishedWork;
  if (finishedWork === null) {
    return;
  }
  if (__DEV__) {
    console.warn("commit阶段开始", finishedWork);
  }
  root.finishedWork = null;
  const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
  if (subtreeHasEffect || rootHasEffect) {
    commitMutationEffects(finishedWork);
    root.current = finishedWork;
  } else {
    root.current = finishedWork;
  }
};
var workLoop = () => {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
};
var performUnitOfWork = (fiber) => {
  const next = beginWork(fiber);
  fiber.memoizedProps = fiber.pendingProps;
  if (next === null) {
    completeUnitOfWork(fiber);
  } else {
    workInProgress = next;
  }
};
function completeUnitOfWork(fiber) {
  let node = fiber;
  do {
    completeWork(node);
    const sibling = node.sibling;
    if (sibling !== null) {
      workInProgress = sibling;
      return;
    }
    node = node.return;
    workInProgress = node;
  } while (node !== null);
}

// packages/react-reconciler/src/fiberReconciler.ts
var createContainer = (container) => {
  const hostRootFiber = new FiberNode(HostRoot, {}, null);
  const root = new FiberRootNode(container, hostRootFiber);
  hostRootFiber.updateQueue = createUpdateQueue();
  return root;
};
var updateContainer = (element, root) => {
  const hostRootFiber = root.current;
  const update = createUpdate(element);
  enqueueUpdate(
    hostRootFiber.updateQueue,
    update
  );
  scheduleUpdateOnFiber(hostRootFiber);
  return element;
};

// packages/react-dom/src/root.ts
var createRoot = (container) => {
  const root = createContainer(container);
  return {
    render(element) {
      updateContainer(element, root);
    }
  };
};

// packages/react-dom/index.ts
var react_dom_default = root_exports;
export {
  react_dom_default as default
};
//# sourceMappingURL=react-dom.js.map
